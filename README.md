[![Code Smells](https://sonarcloud.io/api/project_badges/measure?project=Chawotto_java-algorythm&metric=code_smells)](https://sonarcloud.io/summary/new_code?id=Chawotto_java-algorythm)

Cсылка на Sonar: https://sonarcloud.io/summary/new_code?id=Chawotto_java-algorythm

# Раздел 1.3 Контейнеры, очереди, стеки:

Задача 1 (1.3.4)

Напишите клиент стека Parentheses, который читает поток символов из стандартного ввода и использует стек для определения правильности балансировки скобок. Например, программа должна вывести true для {{}[()]} и false для ([{]}]}. 

Расчетное время: 0.091 ч. Время выполнения: 0.081 ч. 

Ссылка на директорию с кодом: [ Очереди_стеки_контейнеры/1/src/main/java/org/example](https://github.com/Chawotto/java-algorythm/tree/103404665159449661dd370bf0768b717ba5a987/%D0%9E%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D0%B8_%D1%81%D1%82%D0%B5%D0%BA%D0%B8_%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D1%8B/1/src/main/java/org/example)

Задача 2 (1.3.14)

Разработайте класс ResizingArrayQueueOfStrings, который реализует обстракцию очереди с массивом фиксированного размера, а потом добавьте в полученную реализацию изменение размера массива, чтобы снять ограничение на размер. 

Расчетное время: 0.241 ч. Время выполнения: 0.2 ч.

Ссылка на директорию с кодом: [ Очереди_стеки_контейнеры/2/src/main/java/org/example](https://github.com/Chawotto/java-algorythm/tree/103404665159449661dd370bf0768b717ba5a987/%D0%9E%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D0%B8_%D1%81%D1%82%D0%B5%D0%BA%D0%B8_%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D1%8B/2/src/main/java/org/example)

Задача 3 (1.3.31)

Реализуйте вложенный класс DoubleNode для построение двухсвязных списков, в которых каждый узел содержит ссылку на узел, предшествующий ему в списке, и ссылку на следующий узел (null, если такого элемента нет). Затем реализуйте статические методы для решения следующих задач: вставка в начало, вставка в конец, удаление из начала, удаление из конца, вставка перед указанным узлом, вставка после указанного узла и удаление указанного узла.

Расчетное время: 0.430 ч. Время выполнения: 0.333 ч. 

Ссылка на директорию с кодом: [ Очереди_стеки_контейнеры/3/src/main/java/org/example](https://github.com/Chawotto/java-algorythm/tree/103404665159449661dd370bf0768b717ba5a987/%D0%9E%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D0%B8_%D1%81%D1%82%D0%B5%D0%BA%D0%B8_%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D1%8B/3/src/main/java/org/example)

Задача 4 (1.3.49)

Реализуйте очередь с помощью фиксированного количества стеков, чтобы каждая операция с очередью требовала выполнения постоянного (в худшем случае) количества операций со стеками.

Расчетное время: 0.575 ч. Время выполнения: 0.533 ч. 

Ссылка на директорию с кодом: [ Очереди_стеки_контейнеры/4/src/main/java/org/example](https://github.com/Chawotto/java-algorythm/tree/103404665159449661dd370bf0768b717ba5a987/%D0%9E%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D0%B8_%D1%81%D1%82%D0%B5%D0%BA%D0%B8_%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D1%8B/4/src/main/java/org/example)

Расчетное время для раздела: 1.337 ч. Время выполнения раздела: 1.147 ч.

# Раздел 2.5 Применение сортировок:

Задача 1 (2.5.8)

Напишите программу Frequency, которая читает строки из стандартного ввода и выводит количество повторений каждой строки, по убыванию частот.

Расчетное время: 0.369 ч. Время выполнения: 0.359 ч.

Ссылка на директорию с кодом: [ Применение_сортировок/1/src/main/java/org/example](https://github.com/Chawotto/java-algorythm/tree/d36a67b86871340c5ec53c91552669c5fa2d7296/%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BE%D0%BA/1/src/main/java/org/example)

Задача 2 (2.5.16)

Выборы без предпочтений. Создайте тип данных, где порядок букв (R...L) является естественным,
и напишите клиент California с единственным статическим методом main(), который упорядочивает строки в таком порядке. *Все строки содержат только прописные буквы.

Расчетное время: 0.336 ч. Время выполнения: 0.328 ч. 

Ссылка на директорию с кодом: [ Применение_сортировок/2/src/main/java/org/example](https://github.com/Chawotto/java-algorythm/tree/d36a67b86871340c5ec53c91552669c5fa2d7296/%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BE%D0%BA/2/src/main/java/org/example)

Задача 3 (2.5.21)

Многомерная сортировка. Напишите типа данных Vector для использования в методах сортировки многомерных векторов, состоящих из d целых чисел. Векторы упорядовачиваются по первому компоненту, векторы с одинаковыми первыми - по второму, с одинаковыми вторыми - по третьему и т.д.

Расчетное время: 0.427 ч. Время выполнения: 0.398 ч. 

Ссылка на директорию с кодом: [ Применение_сортировок/3/src/main/java/org/example](https://github.com/Chawotto/java-algorythm/tree/d36a67b86871340c5ec53c91552669c5fa2d7296/%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BE%D0%BA/3/src/main/java/org/example)

Задача 4 (2.5.29)

Сортировка файлов по размеру и дате последнего изменения. Напишите компараторы для типа File, которые позволяют сортировать файлы по возрастанию/убыванию их размера, по возрастанию/убыванию их имен и по возрастанию/убыванию их даты последнего изменения. Используйте эти компараторы в программе LS, которая принимает из командной строки имя каталога и выводит имена всех находящихся там файлов, упорядоченные по заданному критерию — например, по отметке времени при наличии параметра "-t". Программа должна
поддерживать несколько параметров для более точного упорядочения и использовать устойчивую сортировку.

Расчетное время: 0.727 ч. Время выполнения: 0.712 ч. 

Ссылка на директорию с кодом: [ Применение_сортировок/4/src/main/java/org/example](https://github.com/Chawotto/java-algorythm/tree/d36a67b86871340c5ec53c91552669c5fa2d7296/%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BE%D0%BA/4/src/main/java/org/example)

Расчетное время для раздела: 1.859 ч. Время выполнения раздела: 1.797 ч.

# Раздел 3.2 Деревья бинарного поиска:

Задача 1 (3.2.8)

Напишите статический метод optComparesO, который принимает целочисленный аргумент N и вычисляет количество сравнений, необходимых для случайного попадания в оптимальном (идеально сбалансированном) ДБП, где все нулевые ссылки находятся на одном и том же уровне, если количество ссылок равно степени 2, или иначе на двух соседних уровнях.

Расчетное время: 0.416 ч. Время выполнения: 0.397 ч. 

Ссылка на директорию с кодом: [Деревья_бинарного_поиска/1/src/main/java/org/example](https://github.com/Chawotto/java-algorythm/tree/80568e33ea502fd39114ff6b0c7b499cf1331878/%D0%94%D0%B5%D1%80%D0%B5%D0%B2%D1%8C%D1%8F_%D0%B1%D0%B8%D0%BD%D0%B0%D1%80%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0/1/src/main/java/org/example)

Задача 2 (3.2.29)

Проверка бинарного дерева. Напишите рекурсивный метод isBinaryTreeO, который принимает в качестве аргумента узел Node и возвращает true, если счетчик узлов N для поддерева с указанным корнем верен, и false в противном случае.

Расчетное время: 0.630 ч. Время выполнения: 0.582 ч. 

Ссылка на директорию с кодом: [Деревья_бинарного_поиска/2/src/main/java/org/example](https://github.com/Chawotto/java-algorythm/tree/80568e33ea502fd39114ff6b0c7b499cf1331878/%D0%94%D0%B5%D1%80%D0%B5%D0%B2%D1%8C%D1%8F_%D0%B1%D0%B8%D0%BD%D0%B0%D1%80%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0/2/src/main/java/org/example)

Задача 3 (3.2.37)

Поуровневый обход. Напишите метод printLevel(), который принимает в качестве аргумента узел Node и выводит ключи из поддерева с корнем в указанном узле по уровням — т.е. в порядке их расстояния до корня, а для узлов с одинаковым расстоянием в порядке слева направо. Совет: воспользуйтесь классом Queue.

Расчетное время: 0.869 ч. Время выполнения: 0.798 ч. 

Ссылка на директорию с кодом: [Деревья_бинарного_поиска/3/src/main/java/org/example](https://github.com/Chawotto/java-algorythm/tree/80568e33ea502fd39114ff6b0c7b499cf1331878/%D0%94%D0%B5%D1%80%D0%B5%D0%B2%D1%8C%D1%8F_%D0%B1%D0%B8%D0%BD%D0%B0%D1%80%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0/3/src/main/java/org/example)

Задача 4 (3.2.28)

Вычерчивание дерева. Добавьте в класс ВЅT метод draw(), который вычерчивает ДБП в стиле рисунков, приведенных в тексте. Совет: используйте переменные экземпляров для хранения координат узлов и рекурсивный метод для задания значений этих переменных.

Расчетное время: 1.444 ч. Время выполнения: 1.111 ч. 

Ссылка на директорию с кодом: [Деревья_бинарного_поиска/4/src/main/java/org/example](https://github.com/Chawotto/java-algorythm/tree/80568e33ea502fd39114ff6b0c7b499cf1331878/%D0%94%D0%B5%D1%80%D0%B5%D0%B2%D1%8C%D1%8F_%D0%B1%D0%B8%D0%BD%D0%B0%D1%80%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0/4/src/main/java/org/example)

Расчетное время для раздела: 3.359 ч. Время выполнения раздела: 2.888 ч.

# Раздел 3.3 Сбалансированные деревья поиска:

Задача 1 (3.3.23)

Разработайте реализацию базового API таблицы имен на основе 2-3-деревьев, которые не обязательно сбалансированы. Разрешите наклон 3-узлов в любую сторону. При вставке в 3-узел на нижнем уровне прикрепляйте новый узел черной связью. Проведите эксперименты и на их основе сформулируйте гипотезу с оценкой средней длины пути в дереве, построенном N случайными вставками.

Ссылка на директорию с кодом: [Сбалансированные_деревья_поиска\1\src\main\java\org\example](https://github.com/Chawotto/java-algorythm/tree/756224a16a56bb763ae0625902bd9eb69bab6441/%D0%A1%D0%B1%D0%B0%D0%BB%D0%B0%D0%BD%D1%81%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D1%8C%D1%8F_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0/1/src/main/java/org/example)

Расчетное время: 0.672 ч. Время выполнения: 0.832 ч. 

Задача 2 (3.3.35)

Напишите программу TwoThreeST.java, которая использует два типа узлов для непосредственной реализации 2-3-деревьев поиска.

Расчетное время: 0.852 ч. Время выполнения: 0.721 ч. 

Ссылка на директорию с кодом: [Сбалансированные_деревья_поиска\2\src\main\java\org\example](https://github.com/Chawotto/java-algorythm/tree/4070b8bb2d3cd34d17e95c449ffb4139d2a49288/%D0%A1%D0%B1%D0%B0%D0%BB%D0%B0%D0%BD%D1%81%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D1%8C%D1%8F_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0/2/src/main/java/org/example)

Задача 3 (3.3.37)

Покажите, что красно-черные ДБП обладают памятью: например, если вставить в него ключ, меньший всех других ключей , и сразу же удалить наименьший ключ, то может получиться другое дерево.

Расчетное время: 1.2 ч. Время выполнения: 0.989 ч.

Ссылка на директорию с кодом: [Сбалансированные_деревья_поиска\3\src\main\java\org\example](https://github.com/Chawotto/java-algorythm/tree/bd119248dea73ac925ee6755522af2ee6c7083e3/%D0%A1%D0%B1%D0%B0%D0%BB%D0%B0%D0%BD%D1%81%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D1%8C%D1%8F_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0/3/src/main/java/org/example)

Задача 4 (3.3.42)

Напишите программу, которая вычисляет процент красных узлов в заданном красно-черном ДБП. проверьте работу программы, выполнив, по крайней мере, 100 раз вставку N случайных ключей в первоначально пустое дерево, для N = 10000, N = 100000, N = 1000000, и сформулируйте гипотезу.

Расчетное время: 1 ч. Время выполнения: 0.778 ч.

Ссылка на директорию с кодом: [Сбалансированные_деревья_поиска\4\src\main\java\org\example](https://github.com/Chawotto/java-algorythm/tree/2fd9ee9799f20a90d7f7fee2533961375124a5da/%D0%A1%D0%B1%D0%B0%D0%BB%D0%B0%D0%BD%D1%81%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D1%8C%D1%8F_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0/4/src/main/java/org/example)

Расчетное время для раздела: 3.724 ч. Время выполнения раздела: 3.311 ч.

#	Раздел 3.4 Хеш-таблицы:

Задача 1 (3.4.11)

Приведите содержимое хеш-таблицы с линейным опробованием, которая получится после вставки ключей E A S Y Q U T I O N в указанном порядке в первоначально пустую таблицу с первоначальным размером М = 4, которая удваивает размер при заполнении наполовину. Для преобразования k-й буквы алфавита в индекс таблицы используйте хеш-функцию 11 k % М.

Расчетное время: 0.221 ч. Время выполнения: 0.179 ч.

Ссылка на директорию с кодом: [Хеш-таблицы\1\src\main\java\org\example](https://github.com/Chawotto/java-algorythm/tree/1b0e5465a3d0237e3b528385ddc7a2b0a6ace884/%D0%A5%D0%B5%D1%88-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D1%8B/1/src/main/java/org/example)

Задача 2 (3.4.23)

Пусть используется модульное хеширование для строковых ключей с R = 256 и М = 255. Покажите, что этот выбор неудачен, т.к. любая перестановка букв в строке хешируется в одно и то же значение.

Расчетное время: 0.272 ч. Время выполнения: 0.192 ч.

Ссылка на директорию с кодом: [Хеш-таблицы\2\src\main\java\org\example](https://github.com/Chawotto/java-algorythm/tree/2b5300bd408109f53426e2dc16f8d380c91faa90/%D0%A5%D0%B5%D1%88-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D1%8B/2/src/main/java/org/example)


Задача 3 (3.4.36) 

Диапазон длин списков. Напишите программу, которая вставляет N ключей int в таблицу размером N/100 с раздельными цепочками, а затем определяет длину самого короткого и самого длинного списков, для N = 10000, 100000, 1000000 и 10000000.

Расчетное время: 0.256 ч. Время выполнения: 0.174 ч.

Ссылка на директорию с кодом: [Хеш-таблицы\3\src\main\java\org\example](https://github.com/Chawotto/java-algorythm/tree/b8eb2ca82a30b20dca6334348d8ffe6b38895c03/%D0%A5%D0%B5%D1%88-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D1%8B/3/src/main/java/org/example)

Задача 4 (3.4.39)

Распределение с линейным опробованием. Напишите программу, которая вставляет N/2 случайных ключей типа int в таблицу размером N с линейным опробованием, а затем вычисляет среднюю стоимость промахов в полученной таблице в зависимости от длин кластеров, для N = 10000, 100000, 1000000 и 10000000.

Расчетное время: 0.212 ч. Время выполнения: 0.184 ч.

Ссылка на директорию с кодом: [Хеш-таблицы\4\src\main\java\org\example](https://github.com/Chawotto/java-algorythm/tree/02be98ab2b785ef0dfd06e5081b07b85bd13985c/%D0%A5%D0%B5%D1%88-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D1%8B/4/src/main/java/org/example)

Расчетное время для раздела: 1 ч. Время выполнения раздела: 0.8 ч.

#	Раздел 5.1 Сортировка строк:

Задача 1 (5.1.11)

Сортировка с помощью очередей. Реализуйте MSD-сортировку строк с помощью очередей. Для каждого кармана используйте отдельную очередь. На первом проходе по сортируемым элементам вставляйте каждый элемент в очередь, соответствующую значению ее старшего символа. Потом отсортируйте подсписки и объедините содержимое очередей в единый результат. Обратите внимание, что в этом методе не требуется хранить массивы count[] внутри рекурсивного метода.

Расчетное время: 0.311 ч. Время выполнения: 0.279 ч.

Ссылка на директорию с кодом: [Сортировка_строк\1\src\main\java\org\example](https://github.com/Chawotto/java-algorythm/tree/d56cbe65b37978cea57177e0d8bf59a84402a741/%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D1%81%D1%82%D1%80%D0%BE%D0%BA/1/src/main/java/org/example)

Задача 2 (5.1.14) 

Сортировка массивов. Разработайте метод, в котором трехчастная быстрая сортировка строк применяется для ключей, представляющих собой массивы целых чисел.

Расчетное время: 0.25 ч. Время выполнения: 0.2 ч.

Ссылка на директорию с кодом: [Сортировка_строк\2\src\main\java\org\example](https://github.com/Chawotto/java-algorythm/tree/d82d8af94af6acdff107153782d1f9e7ffb2f214/%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D1%81%D1%82%D1%80%D0%BE%D0%BA/2/src/main/java/org/example)

Задача 3 (5.1.19)

Случайные автомобильные номера. Напишите статический метод randomPlatesCA, который принимает в качестве аргумента целое значение N и возвращает массив из N значений типа String, которые представляют собой автомобильные номера вроде приведенных в примерах данного раздела.

Расчетное время: 0.3 ч. Время выполнения: 0.27 ч.

Ссылка на директорию с кодом: [Сортировка_строк\3\src\main\java\org\example](https://github.com/Chawotto/java-algorythm/tree/df002418c9d5e4a3c656c39b67a568a252434462/%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D1%81%D1%82%D1%80%D0%BE%D0%BA/3/src/main/java/org/example)

Задача 4 (5.1.21) 

Случайные элементы. Напишите статический метод randomItems, который принимает в качестве аргумента целое значение N и возвращает массив из строковых значений длиной от 15 до 30 символов, которые состоят из четырех полей: 4-символьное поле с одной из 10 фиксированных строк; 10-символьное поле с одной из 50 фиксированных строк; 1-символьное поле с одним из двух заданных значений; и 15-байтовое поле с (равновероятно) случайными выровненными влево строками символов длиной от 4 до 15 символов.

Расчетное время: 0.8 ч. Время выполнения: 0.68 ч.

Ссылка на директорию с кодом: [Сортировка_строк\4\src\main\java\org\example](https://github.com/Chawotto/java-algorythm/tree/9901a1a1e529eee65fbe35e55652a9e5d8ceba41/%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D1%81%D1%82%D1%80%D0%BE%D0%BA/4/src/main/java/org/example)

Расчетное время для раздела: 1.66 ч. Время выполнения раздела: 1.42 ч.

#	Раздел 5.2 Trie-деревья:

Задача 1 (5.2.6) 

Реализуйте API для типа данных StringSET, приведенный на рис. 5.2.14.

Расчетное время: 0.5 ч. Время выполнения: 0.45 ч.

Ссылка на директорию с кодом: [Trie-деревья\1\src\main\java\org\example](https://github.com/Chawotto/java-algorythm/tree/781dd877111b4cbeee17b42c6ee2cad6ce4e1450/Trie-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D1%8C%D1%8F/1/src/main/java/org/example)

Задача 2 (5.2.14) 

Уникальные подстроки длиной L. Напишите клиент TST, который вводит текст из стандартного ввода и подсчитывает в нем количество уникальных подстрок длиной. Например, входной текст cgcgggcgcg содержит пять уникальных подстрок длиной 3 cgc, cgg, gcg, ggc и ggg. Совет: выберите 1-ю подстроку с помощью вызова substring(i, i + L) и вставьте ее в таблицу имен.

Расчетное время: 0.8 ч. Время выполнения: 0.74 ч.

Ссылка на директорию с кодом: [Trie-деревья\2\src\main\java\org\example](https://github.com/Chawotto/java-algorythm/tree/781dd877111b4cbeee17b42c6ee2cad6ce4e1450/Trie-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D1%8C%D1%8F/2/src/main/java/org/example)

Задача 3 (5.2.15) 

Уникальные подстроки. Напишите клиент TST, который вводит текст из стандартного ввода и подсчитывает в нем количество уникальных подстрок любых длин. Это можно очень эффективно выполнить с помощью дерева суффиксов см. главу 6.

Расчетное время: 0.5 ч. Время выполнения: 0.44 ч.

Ссылка на директорию с кодом: [Trie-деревья\3\src\main\java\org\example](https://github.com/Chawotto/java-algorythm/tree/781dd877111b4cbeee17b42c6ee2cad6ce4e1450/Trie-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D1%8C%D1%8F/3)

Задача 4 (5.2.21) 

Сопоставление подстрок. Пусть задан список (коротких) строк и нужно отвечать на запросы, где пользователь ищет строку s - возвращать все строки из списка, которые содержат s. Разработайте для этой задачи API и клиент ТТП, реализующий этот АРІ. Совет: вставляйте в ТТП суффиксы каждого слова (например, победа, обеда, беда, еда, да, а).

Расчетное время: 1 ч. Время выполнения: 0.87 ч.

Ссылка на директорию с кодом: [Trie-деревья\4\src\main\java\org\example](https://github.com/Chawotto/java-algorythm/tree/781dd877111b4cbeee17b42c6ee2cad6ce4e1450/Trie-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D1%8C%D1%8F/4/src/main/java/org/example)

Расчетное время для раздела: 2.8 ч. Время выполнения раздела: 2.5 ч.

#	Раздел 5.3 Поиск подстрок:

Задача 1 (5.3.23)

Напишите программу, которая считывает символы по одному и сообщает о каждом случае, когда текущая строка является палиндромом. Совет: используйте принцип хеширования Рабина-Карпа.

Расчетное время: 0.5 ч. Время выполнения: 0.45 ч.

Ссылка на директорию с кодом: [Поиск_подстрок\1\src\main\java\org\example]()

Задача 2 (5.3.26)

Проверка наличия циклических перестановок. Напишите программу, которая для заданных двух строк определяет, является ли одна из них циклической перестановкой другой например, пальто и топаль.

Расчетное время: 0.4 ч. Время выполнения: 0.4 ч.

Ссылка на директорию с кодом: [Поиск_подстрок\2\src\main\java\org\example]()

Задача 3 (5.3.36)

Случайный текст. Напишите программу, которая принимает в качестве аргументов целые числа M и N, генерирует случайную строку двоичного текста длиной N, а затем подсчитывает количество вхождений последних М битов в других местах этой строки. Примечание: для различных значений М могут быть удобны различные методы.

Расчетное время: 0.8 ч. Время выполнения: 1 ч.

Ссылка на директорию с кодом: [Поиск_подстрок\3\src\main\java\org\example]()

Задача 4 (5.3.37)

Поиск Кнута-Морриса-Пратта для случайного текста. Напишите клиент, который принимает в качестве входных параметров целые значения М, N и Т и выполняет T раз следующий эксперимент: 
Генерируется случайный образец длиной М и случайный текст длиной N, а затем подсчитывается количество сравнений символов при поиске образца в тексте с помощью реализации КМР. Добавьте в класс КМР возможность подсчета сравнений и выведите среднее значение для Т повторений.

Расчетное время: 1.2 ч. Время выполнения: 0.9 ч.

Ссылка на директорию с кодом: [Поиск_подстрок\4\src\main\java\org\example]()

Расчетное время для раздела: 2.9 ч. Время выполнения раздела: 2.75 ч.

#	Раздел 5.4 Регулярные выражения:
